---
doc_type: weread-highlights-reviews
bookId: '30179235'
author: 柴树杉 曹春晖
cover: >-
  https://wfqqreader-1252317822.image.myqcloud.com/cover/235/30179235/t7_30179235.jpg
reviewCount: 0
noteCount: 16
title: 《Go语言高级编程》
categories:
  - 4_booking
  - 01进行中
abbrlink: f7a9a4c0
date: 2023-09-05 00:00:00
---


## 第4章 RPC和Protobuf


- 📌 RPC是远程过程调用（Remote Procedure Call）的缩写，通俗地说就是调用远处的一个函数。远处到底有多远呢？可能是同一个文件内的不同函数，也可能是同一个机器的另一个进程的函数，还可能是远在火星好奇号上面的某个秘密方法。因为RPC涉及的函数可能非常远，远到它们之间说着完全不同的语言，所以语言就成了两边的沟通障碍。而Protobuf由于支持多种不同的语言（甚至不支持的语言也可以扩展支持），其本身特性也非常方便描述服务的接口（也就是方法列表），因此非常适合作为RPC世界的接口交流语言。 
    - ⏱ 2023-09-03 09:01:14 
## 4.1 RPC入门


- 📌 其中rpc.RegisterName()函数调用会将对象类型中所有满足RPC规则的对象方法注册为RPC函数，所有注册的方法会放在HelloService服务的空间之下。然后建立一个唯一的TCP链接，并且通过rpc.ServeConn()函数在该TCP链接上为对方提供RPC服务。 
    - ⏱ 2023-09-03 09:21:36 

- 📌 首先是通过rpc.Dial拨号RPC服务，然后通过client.Call()调用具体的RPC方法。在调用client.Call()时，第一个参数是用点号链接的RPC服务名字和方法名字，第二个和第三个参数分别是定义RPC方法的两个参数 
    - ⏱ 2023-09-03 09:18:46 

- 📌 标准库的RPC默认采用Go语言特有的Gob编码，因此从其他语言调用Go语言实现的RPC服务将比较困难。 
    - ⏱ 2023-09-03 09:24:03 

- 📌 Go语言的RPC框架有两个比较有特色的设计：一个是RPC数据打包时可以通过插件实现自定义的编码和解码；另一个是RPC建立在抽象的io.ReadWriteCloser接口之上，我们可以将RPC架设在不同的通信协议之上。 
    - ⏱ 2023-09-03 09:24:41 
## 4.2 Protobuf


- 📌 第3版的Protobuf对语言进行了提炼简化，所有成员均采用类似Go语言中的零值初始化（不再支持自定义默认值），因此消息成员也不再需要支持required特性。 
    - ⏱ 2023-09-03 09:30:48 

- 📌 其实用Protobuf定义与语言无关的RPC服务接口才是它真正的价值所在 
    - ⏱ 2023-09-03 09:33:28 

- 📌 Protobuf的protoc编译器是通过插件机制实现对不同语言的支持。例如，如果protoc命令出现--xxx_out格式的参数，那么protoc将首先查询是否有内置的xxx插件，如果没有内置的xxx插件，将继续查询当前系统中是否存在以protoc-gen-xxx命名的可执行程序，最终通过查询到的插件生成代码。 
    - ⏱ 2023-09-03 09:35:34 
## 4.3 玩转RPC


- 📌 通常的RPC是基于客户/服务器结构，RPC的服务器端对应网络的服务器，RPC的客户端也对应网络客户端。但是对于一些特殊场景，例如，在公司内网提供一个RPC服务，但是在外网无法链接到内网的服务器，这种时候我们可以参考类似反向代理的技术，首先从内网主动链接到外网的TCP服务器，然后基于TCP链接向外网提供RPC服务。 
    - ⏱ 2023-09-03 09:39:57 
## 4.4 gRPC入门


- 📌 gRPC是谷歌公司基于Protobuf开发的跨语言的开源RPC框架。gRPC基于HTTP/2协议设计，可以基于一个HTTP/2链接提供多个服务，对移动设备更加友好 
    - ⏱ 2023-09-03 09:42:20 

- 📌 gRPC和标准库的RPC框架有一个区别，即gRPC生成的接口并不支持异步调用。不过，我们可以在多个Goroutine之间安全地共享gRPC底层的HTTP/2链接，因此可以通过在另一个Goroutine阻塞调用的方式模拟异步调用。 
    - ⏱ 2023-09-03 09:45:07 

- 📌 RPC是远程函数调用，因此每次调用的函数参数和返回值不能太大，否则将严重影响每次调用的响应时间。因此传统的RPC方法调用对上传和下载较大数据量的场景并不适合。同时传统RPC模式也不适用于时间不确定的订阅和发布模式。为此，gRPC框架针对服务器端和客户端分别提供了流特性。 
    - ⏱ 2023-09-03 09:45:48 
## 4.5 gRPC进阶


- 📌 gRPC建立在HTTP/2协议之上，对TLS提供了很好的支持。4.4节中gRPC的服务都没有提供证书支持，因此客户端在链接服务器中通过grpc.WithInsecure()选项跳过了对服务器证书的验证。没有启用证书的gRPC服务和客户端进行的是明文通信，信息面临被任何第三方监听的风险。 
    - ⏱ 2023-09-03 09:52:11 

- 📌 gRPC构建在HTTP/2协议之上，因此我们可以将gRPC服务和普通的Web服务架设在同一个端口之上。 
    - ⏱ 2023-09-03 09:54:00 

- 📌 首先gRPC建立在HTTP/2版本之上，如果HTTP不是HTTP/2协议则必然无法提供gRPC支持。同时，每个gRPC调用请求的Content-Type类型会被标注为"application/grpc"类型。这样就可以在gRPC端口上同时提供Web服务了。 
    - ⏱ 2023-09-03 09:55:21 
## 6.2 分布式锁


- 📌 在单机系统中，尝试锁并不是一个好选择，因为大量的Goroutine抢锁可能会导致CPU无意义的资源浪费。有一个专有名词用来描述这种抢锁的场景——活锁。活锁指的是程序看起来在正常执行，但实际上CPU周期被浪费在抢锁而非执行任务上，从而导致程序整体的执行效率低下。活锁的问题定位起来要麻烦很多，所以在单机场景下，不建议使用这种锁。 
    - ⏱ 2023-09-05 08:56:54 

# 读书笔记


# 本书评论
