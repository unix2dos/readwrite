---
doc_type: weread-highlights-reviews
bookId: CB_3GS3Oi3PzCth6hh6gbEmj3qo
author: 姜承尧
cover: 'https://res.weread.qq.com/wrepub/CB_3GS3Oi3PzCth6hh6gbEmj3qo_parsecover'
reviewCount: 6
noteCount: 28
title: 《MySQL技术内幕：InnoDB存储引擎 第2版》
categories:
  - 4_booking
  - 01进行中
abbrlink: 53dba8d
date: 2023-07-12 00:00:00
---

---


## 2.1 InnoDB存储引擎概述


- 📌 Heikki Tuuri（1964年，芬兰赫尔辛基）是InnoDB存储引擎的创始人，和著名的Linux创始人Linus是芬兰赫尔辛基大学校友。 
    - ⏱ 2023-07-12 16:40:26 
## 3.1 参数文件


- 📌 Oracle数据库存在所谓的隐藏参数（undocumented parameter），以供Oracle“内部人士”使用，SQL Server也有类似的参数。有些DBA曾问我，MySQL中是否也有这类参数。我的回答是：没有，也不需要。即使Oracle和SQL Server中都有些所谓的隐藏参数，在绝大多数的情况下，这些数据库厂商也不建议用户在生产环境中对其进行很大的调整。 
    - ⏱ 2023-07-11 19:43:22 
## 3.2.4 二进制日志


- 📌 二进制日志文件在默认情况下并没有启动，需要手动指定参数来启动。可能有人会质疑，开启这个选项是否会对数据库整体性能有所影响。不错，开启这个选项的确会影响性能，但是性能的损失十分有限。根据MySQL官方手册中的测试表明，开启二进制日志会使性能下降1%。但考虑到可以使用复制（replication）和point-in-time的恢复，这些性能损失绝对是可以且应该被接受的。 
    - ⏱ 2023-07-11 19:47:17 
## 4.1 索引组织表


- 📌 如果在创建表时没有显式地定义主键，则InnoDB存储引擎会按如下方式选择或创建主键：❑首先判断表中是否有非空的唯一索引（Unique NOT NULL），如果有，则该列即为主键。❑如果不符合上述条件，InnoDB存储引擎自动创建一个6字节大小的指针。 
    - ⏱ 2023-07-11 19:49:19 

- 📌 InnoDB存储引擎将选择建表时第一个定义的非空唯一索引为主键。这里需要非常注意的是，主键的选择根据的是定义索引的顺序，而不是建表时列的顺序。 
    - ⏱ 2023-07-11 19:49:53 
## 4.2 InnoDB逻辑存储结构


- 📌 从InnoDB存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个空间中，称之为表空间（tablespace）。表空间又由段（segment）、区（extent）、页（page）组成 
    - ⏱ 2023-07-11 19:51:31 
## 4.2.2 段


- 📌 InnoDB存储引擎表是索引组织的（index organized），因此数据即索引，索引即数据。那么数据段即为B+树的叶子节点（图4-1的Leaf node segment），索引段即为B+树的非索引节点（图4-1的Non-leaf node segment） 
    - ⏱ 2023-07-11 19:54:35 
## 4.2.3 区


- 📌 区是由连续页组成的空间，在任何情况下每个区的大小都为1MB。为了保证区中页的连续性，InnoDB存储引擎一次从磁盘申请4～5个区。在默认情况下，InnoDB存储引擎页的大小为16KB，即一个区中一共有64个连续的页。InnoDB 1.0.x版本开始引入压缩页，即每个页的大小可以通过参数KEY_BLOCK_SIZE设置为2K、4K、8K，因此每个区对应页的数量就应该为512、256、128。InnoDB 1.2.x版本新增了参数innodb_page_size，通过该参数可以将默认页的大小设置为4K、8K，但是页中的数据库不是压缩。这时区中页的数量同样也为256、128。总之，不论页的大小怎么变化，区的大小总是为1M。 
    - ⏱ 2023-07-11 20:44:36 

- 📌 但是，这里还有这样一个问题：在用户启用了参数innodb_file_per_talbe后，创建的表默认大小是96KB。区中是64个连续的页，创建的表的大小至少是1MB才对啊？其实这是因为在每个段开始时，先用32个页大小的碎片页（fragment page）来存放数据，在使用完这些页之后才是64个连续页的申请。 
    - ⏱ 2023-07-11 20:51:51 
## 4.2.4 页


- 📌 同大多数数据库一样，InnoDB有页（Page）的概念（也可以称为块），页是InnoDB磁盘管理的最小单位。在InnoDB存储引擎中，默认每个页的大小为16KB。而从InnoDB 1.2.x版本开始，可以通过参数innodb_page_size将页的大小设置为4K、8K、16K。若设置完成，则所有表中页的大小都为innodb_page_size，不可以对其再次进行修改。除非通过mysqldump导入和导出操作来产生新的库。 
    - ⏱ 2023-07-11 20:59:32 

- 📌 在InnoDB存储引擎中，常见的页类型有：❑数据页（B-tree Node）❑undo页（undo Log Page）❑系统页（System Page） 
    - ⏱ 2023-07-11 20:59:45 
## 4.2.5 行

 
## 4.3 InnoDB行记录格式


- 📌 InnoDB存储引擎和大多数数据库一样（如Oracle和Microsoft SQL Server数据库），记录是以行的形式存储的。这意味着页中保存着表中一行行的数据 
    - ⏱ 2023-07-11 21:03:36 

- 📌 变长字段的长度最大不可以超过2字节，这是因在MySQL数据库中VARCHAR类型的最大长度限制为65535。 
    - ⏱ 2023-07-11 21:06:32 

- 📌 最后的部分就是实际存储每个列的数据。需要特别注意的是，NULL不占该部分任何空间，即NULL除了占有NULL标志位，实际存储不占有任何空间。另外有一点需要注意的是，每行数据除了用户定义的列外，还有两个隐藏列，事务ID列和回滚指针列，分别为6字节和7字节的大小。若InnoDB表没有定义主键，每行还会增加一个6字节的rowid列。 
    - ⏱ 2023-07-11 21:08:09 

- 📌 03 02 01/*变长字段长度列表，逆序*/00/*NULL标志位，第一行没有NULL值*/00 00 10 00 2c/*Record Header，固定5字节长度*/00 00 00 2b 68 00/*RowID InnoDB自动创建，6字节*/00 00 00 00 06 05/*TransactionID*/80 00 0000 32 01 10/*Roll Pointer*/61/*列1数据'a'*/62 62/*列2数据'bb'*/62 62 20 20 20 20 20 20 20 20/*列3数据'bb'*/63 63 63/*列4数据'ccc'*/现在第一行数据就展现在用户眼前了。需要注意的是，变长字段长度列表是逆序存放的，因此变长字段长度列表为03 02 01，而不是01 02 03。此外还需要注意InnoDB每行有隐藏列TransactionID和Roll Pointer。同时可以发现，固定长度CHAR字段在未能完全占用其长度空间时，会用0x20来进行填充。 
    - ⏱ 2023-07-11 21:13:26 

- 📌 接着再来分析下Record Header的最后两个字节，这两个字节代表next_recorder，0x2c代表下一个记录的偏移量，即当前记录的位置加上偏移量0x2c就是下条记录的起始位置。所以InnoDB存储引擎在页内部是通过一种链表的结构来串连各个行记录的。 
    - ⏱ 2023-07-11 21:11:58 

- 📌 03 01/*变长字段长度列表，逆序*/06/*NULL标志位，第三行有NULL值*/00 00 20 ff 98/*Record Header*/00 00 00 2b 68 02/*RowID*/00 00 00 00 06 07/*TransactionID*/80 00 00 00 32 01 10/*Roll Pointer*/64/*列1数据'd'*/66 66 66/*列4数据'fff'*/第三行有NULL值，因此NULL标志位不再是00而是06，转换成二进制为00000110，为1的值代表第2列和第3列的数据为NULL。在其后存储列数据的部分，用户会发现没有存储NULL列，而只存储了第1列和第4列非NULL的值。因此这个例子很好地说明了：不管是CHAR类型还是VARCHAR类型，在compact格式下NULL值都不占用任何存储空间。 
    - ⏱ 2023-07-11 21:13:07 
## 4.3.2 Redundant行记录格式


- 📌 从表4-2中可以发现，n_fields值代表一行中列的数量，占用10位。同时这也很好地解释了为什么MySQL数据库一行支持最多的列为1023。 
    - ⏱ 2023-07-11 21:16:13 

- 📌 VARCHAR类型的NULL值，Redundant行记录格式同样不占用任何存储空间，而CHAR类型的NULL值需要占用空间。 
    - ⏱ 2023-07-11 21:17:13 
## 4.3.3 行溢出数据


- 📌 InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。一般认为BLOB、LOB这类的大对象列类型的存储会把数据存放在数据页面之外。但是，这个理解有点偏差，BLOB可以不将数据放在溢出页面，而且即便是VARCHAR列数据类型，依然有可能被存放为行溢出数据。 
    - ⏱ 2023-07-11 21:18:09 

- 📌 从错误消息可以看到InnoDB存储引擎并不支持65535长度的VARCHAR。这是因为还有别的开销，通过实际测试发现能存放VARCHAR类型的最大长度为65532。例如，按下面的命令创建表就不会报错了。mysql＞CREATE TABLE test(-＞a VARCHAR(65532)-＞)CHARSET=latin1 ENGINE=InnoDB;Query OK,0 rows affected(0.15 sec) 
    - ⏱ 2023-07-11 21:18:56 

- 📌 此外需要注意的是，MySQL官方手册中定义的65535长度是指所有VARCHAR列的长度总和，如果列的长度总和超出这个长度，依然无法创建，如下所示：mysql＞CREATE TABLE test2(-＞a VARCHAR(22000),-＞b VARCHAR(22000),-＞c VARCHAR(22000)-＞)CHARSET=latin1 ENGINE=InnoDB;ERROR 1118(42000):Row size too large.The maximum row size for the used table type,not counting BLOBs,is 65535.You have to change some columns to TEXT or BLOBs3个列长度总和是66000，因此InnoDB存储引擎再次报了同样的错误。即使能存放65532个字节，但是有没有想过，InnoDB存储引擎的页为16KB，即16384字节，怎么能存放65532字节呢？因此，在一般情况下，InnoDB存储引擎的数据都是存放在页类型为B-tree node中。但是当发生行溢出时，数据存放在页类型为Uncompress BLOB页中。 
    - ⏱ 2023-07-11 21:20:24 

- 📌 另一个问题是，对于TEXT或BLOB的数据类型，用户总是以为它们是存放在Uncompressed BLOB Page中的，其实这也是不准确的。是放在数据页中还是BLOB页中，和前面讨论的VARCHAR一样，至少保证一个页能存放两条记录， 
    - ⏱ 2023-07-11 21:28:45 
## 4.3.4 Compressed和Dynamic行记录格式


- 📌 InnoDB 1.0.x版本开始引入了新的文件格式（file format，用户可以理解为新的页格式），以前支持的Compact和Redundant格式称为Antelope文件格式，新的文件格式称为Barracuda文件格式。Barracuda文件格式下拥有两种新的行记录格式：Compressed和Dynamic。新的两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式，如图4-5所示，在数据页中只存放20个字节的指针，实际的数据都存放在Off Page中，而之前的Compact和Redundant两种格式会存放768个前缀字节。 
    - ⏱ 2023-07-11 21:32:04 

- 📌 Compressed行记录格式的另一个功能就是，存储在其中的行数据会以zlib的算法进行压缩，因此对于BLOB、TEXT、VARCHAR这类大长度类型的数据能够进行非常有效的存储。 
    - ⏱ 2023-07-11 21:32:19 
## 4.3.5 CHAR的行结构存储


- 📌 可以看到对于字符串'ab'，其内部存储为0x6162。而字符串'我们'为0xCED2C3C7。因此对于多字节的字符编码，CHAR类型不再代表固定长度的字符串了。例如，对于UTF-8下CHAR（10）类型的列，其最小可以存储10字节的字符，而最大可以存储30字节的字符。因此，对于多字节字符编码的CHAR数据类型的存储，InnoDB存储引擎在内部将其视为变长字符类型。这也就意味着在变长长度列表中会记录CHAR数据类型的长度。 
    - ⏱ 2023-07-11 21:34:24 
 

# 读书笔记

## 4.2.3 区

### 划线评论
- 📌 区是由连续页组成的空间，在任何情况下每个区的大小都为1MB。为了保证区中页的连续性，InnoDB存储引擎一次从磁盘申请4～5个区。在默认情况下，InnoDB存储引擎页的大小为16KB，即一个区中一共有64个连续的页。  ^225207353-7JDcMQjuy
    - 💭 16kb * 64 = 1mb
    - ⏱ 2023-07-11 20:58:41

### 划线评论
- 📌 区是由连续页组成的空间，在任何情况下每个区的大小都为1MB。为了保证区中页的连续性，InnoDB存储引擎一次从磁盘申请4～5个区。在默认情况下，InnoDB存储引擎页的大小为16KB，即一个区中一共有64个连续的页。  ^225207353-7JDbOB0wn
    - 💭 一个区64个页📃
    - ⏱ 2023-07-11 20:43:50

### 划线评论
- 📌 区是由连续页组成的空间，在任何情况下每个区的大小都为1MB。为了保证区中页的连续性，InnoDB存储引擎一次从磁盘申请4～5个区。在默认情况下，InnoDB存储引擎页的大小为16KB，即一个区中一共有64个连续的页。  ^225207353-7JDbMNI9R
    - 💭 一个页是16kb
    - ⏱ 2023-07-11 20:43:24
   
## 4.2.5 行

### 划线评论
- 📌 InnoDB存储引擎是面向列的（row-oriented），也就说数据是按行进行存放的。每个页存放的行记录也是有硬性定义的，最多允许存放16KB/2-200行的记录，即7992行记录  ^225207353-7JDd1sCXx
    - 💭 16*1024/2 -200 = 7992
    - ⏱ 2023-07-11 21:02:17
   
## 4.3 InnoDB行记录格式

### 划线评论
- 📌 现在第一行数据就展现在用户眼前了。需要注意的是，变长字段长度列表是逆序存放的，因此变长字段长度列表为03 02 01，而不是01 02 03。  ^225207353-7JDdRvfGG
    - 💭 就是a bb ccc的长度
    - ⏱ 2023-07-11 21:15:06
   
## 4.3.5 CHAR的行结构存储

### 划线评论
- 📌 上述例子清楚地显示了InnoDB存储引擎内部对CHAR类型在多字节字符集类型的存储。CHAR类型被明确视为了变长字符类型，对于未能占满长度的字符还是填充0x20。InnoDB存储引擎内部对字符的存储和我们用HEX函数看到的也是一致的。因此可以认为在多字节字符集的情况下，CHAR和VARCHAR的实际行存储基本是没有区别的。  ^225207353-7JDfcu0sa
    - 💭 多字节字符集，utf8下，用char也是变长
    - ⏱ 2023-07-11 21:35:32
   

# 本书评论
