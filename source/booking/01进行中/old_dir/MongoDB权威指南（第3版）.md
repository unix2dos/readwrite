---
doc_type: weread-highlights-reviews
bookId: "41779824"
author: 香农·布拉德肖 克里斯蒂娜·霍多罗夫 约恩·布拉齐尔
cover: https://wfqqreader-1252317822.image.myqcloud.com/cover/824/41779824/t7_41779824.jpg
reviewCount: 1
noteCount: 35
isbn: 9787115576538
title: 《MongoDB权威指南（第3版）》
date: 2023-10-26
---

---

![ MongoDB权威指南（第3版）|200](https://wfqqreader-1252317822.image.myqcloud.com/cover/824/41779824/t7_41779824.jpg)


## 封面

## 版权信息

## 版权声明

## O'Reilly Media, Inc.介绍

## 业界评论

## 献词

## 前言

## 第一部分 MongoDB 入门

## 1.1 易于使用


- 📌 面向文档的数据库使用更灵活的“文档”模型取代了“行”的概念。通过嵌入文档和数组，面向文档的方式可以仅用一条记录来表示复杂的层次关系，这与使用现代面向对象语言的开发人员思考数据的方式非常契合。 
    - ⏱ 2023-10-14 18:16:14 

- 📌 MongoDB 中也没有预定义模式（predefined schema）：文档键值的类型和大小不是固定的。由于没有固定的模式，因此按需添加或删除字段变得更容易。 
    - ⏱ 2023-10-14 18:16:36 
## 1.2 易于扩展


- 📌 应该如何扩展数据库？这可以归结为两种选择：纵向扩展（提高配置）和横向扩展（将数据分布到更多机器上）。纵向扩展通常是阻力最小的途径，但它也有缺点：大型机器一般非常昂贵，而且在最终达到物理极限时，就无法再升级到更高的配置了。另一种方式是横向扩展：如果想增加存储空间或增加读写操作的吞吐量，那么可以购买额外的服务器，并将它们添加到集群中。这既便宜又便于扩展，但管理 1000 台机器比管理 1 台机器困难得多。 
    - ⏱ 2023-10-14 23:05:48 

- 📌 MongoDB 集群的拓扑结构，或者说其连接的是一个集群还是单个节点，对应用程序来说都是透明的。这使得开发人员能够专注于应用程序的开发，而无须考虑扩展问题。 
    - ⏱ 2023-10-14 23:06:36 
## 1.3 功能丰富


- 📌 MongoDB 并不具备关系数据库中的一些常见功能，特别是复杂的连接操作。MongoDB 通过使用 3.2 版本引入的 $lookup 聚合运算符以非常有限的方式支持连接操作。在 3.6 版本中，可以使用多个连接条件以及非关联子查询来实现更复杂的连接。MongoDB 的这种处理是出于架构上的考虑，以便获得更好的可扩展性，因为这些特性在分布式系统中很难高效地实现。 
    - ⏱ 2023-10-14 23:07:36 
## 1.4 性能卓越

## 1.5 设计理念

## 第 2 章 入门指南

## 2.1 文档


- 📌 文档中的键是字符串类型。除了少数例外的情况，可以使用任意 UTF-8 字符作为键。 
    - ⏱ 2023-10-14 23:08:55 

- 📌 MongoDB 会区分类型和大小写。 
    - ⏱ 2023-10-14 23:09:12 
## 2.2 集合


- 📌 集合具有动态模式的特性。这意味着一个集合中的文档可以具有任意数量的不同“形状”。例如，以下两个文档可以存储在同一个集合中：{"greeting" : "Hello, world!", "views": 3}￼ {"signoff": "Good night, and good luck"} 
    - ⏱ 2023-10-14 23:09:40 

- 📌 对于开发人员和管理员来说，将不同类型的文档保存在同一个集合中可能是一个噩梦。开发人员需要确保每个查询只返回特定模式的文档，或者确保执行查询的应用程序代码可以处理不同类型的文档。如果在查询博客文章时还需要剔除包含作者数据的文档，那么这会非常麻烦。 
    - ⏱ 2023-10-14 23:10:11 

- 📌 使用 . 字符分隔不同命名空间的子集合是一种组织集合的惯例。例如，有一个具有博客功能的应用程序，可能包含名为 blog.posts 和名为 blog.authors 的集合。这只是一种组织管理的方式，blog 集合（它甚至不必存在）与其“子集合”之间没有任何关系。 
    - ⏱ 2023-10-14 23:11:37 
## 2.3 数据库

## 2.4 启动MongoDB

## 2.5 MongoDB shell介绍


- 📌 MongoDB 自带 JavaScript shell，允许使用命令行与 MongoDB 实例进行交互。 
    - ⏱ 2023-10-14 23:13:35 

- 📌 insertOne 函数可以将一个文档添加到集合中。 
    - ⏱ 2023-10-15 12:06:43 

- 📌 find 和 findOne 方法可用于查询集合中的文档。如果只想查看一个文档，可以使用 findOne： 
    - ⏱ 2023-10-15 12:07:36 

- 📌 如果想修改文档，可以使用 updateOne。updateOne 会接受（至少）两个参数：第一个用于查找要更新文档的限定条件，第二个用于描述要进行更新的文档。 
    - ⏱ 2023-10-15 12:07:45 

- 📌 deleteOne 和 deletemany 方法会从数据库中永久删除文档。这两种方法都采用一个指定删除条件的过滤文档作为参数。 
    - ⏱ 2023-10-15 12:08:42 
## 2.6 数据类型

## 2.7 使用MongoDB shell

## 第 3 章 创建、更新和删除文档

## 3.1 插入文档

## 3.2 删除文档

## 3.3 更新文档

## 第 4 章 查询

## 4.1 find简介

## 4.2 查询条件

## 4.3 特定类型的查询


- 📌 如果可能，最好只针对内嵌文档的特定键进行查询。这样，即使数据模式变了，也不会导致所有查询因为需要精确匹配而无法使用。可以使用点表示法对内嵌文档的键进行查询： 
    - ⏱ 2023-10-16 07:07:26 

- 📌 这种点表示法是查询文档和其他文档类型的主要区别。查询文档可以包含点，表示“进入内嵌文档内部”的意思。点表示法也是待插入文档不能包含 . 字符的原因。当人们试图将 URL 保存为键时，常常会遇到这种限制。解决这个问题的一种方法是在插入前或者提取后始终执行全局替换，用点字符替换 URL 中不合法的字符。 
    - ⏱ 2023-10-16 07:07:54 
## 4.4 $where查询


- 📌 安全起见，应该严格限制或消除 "$where" 子句的使用。应该禁止终端用户随意使用 "$where" 子句。 
    - ⏱ 2023-10-16 07:06:23 

- 📌 除非绝对必要，否则不应该使用 "$where" 查询：它们比常规查询慢得多。每个文档都必须从 BSON 转换为 JavaScript 对象，然后通过 "$where" 表达式运行。此外，"$where" 也无法使用索引。 
    - ⏱ 2023-10-16 07:06:39 
## 4.5 游标

## 第二部分 设计应用程序

## 5.1 索引简介


- 📌 "totalDocsExamined" 是 MongoDB 在试图满足查询时查看的文档总数。 
    - ⏱ 2023-10-26 20:34:01 

- 📌 为了使 MongoDB 高效地响应查询，应用程序中的所有查询模式都应该有索引支持。 
    - ⏱ 2023-10-17 09:06:11 

- 📌 现在尝试在 "username" 字段上创建一个索引。要创建索引，需要使用 createIndex 集合方法：> db.users.createIndex({"username" : 1})￼ {￼     "createdCollectionAutomatically" : false,￼     "numIndexesBefore" : 1,￼     "numIndexesAfter" : 2,￼     "ok" : 1￼ } 
    - ⏱ 2023-10-17 09:08:05 

- 📌 要选择为哪些字段创建索引，可以查看常用的查询以及那些需要快速执行的查询，并尝试从中找到一组通用的键。 
    - ⏱ 2023-10-17 09:09:03 

- 📌 对于许多查询模式来说，在两个或更多的键上创建索引是必要的。例如，索引会将其所有值按顺序保存，因此按照索引键对文档进行排序的速度要快得多。然而，索引只有在作为排序的前缀时才有助于排序 
    - ⏱ 2023-10-17 09:10:15 
 

- 📌 db.users.find({"age" : {"$gte" : 21, "$lte" : 30}}).sort({"username" : 1})　　与上一个方式类似，这是多值查询，但这次需要对结果进行排序。和之前一样，MongoDB 会使用索引来匹配查询条件。不过，索引不会按照顺序返回用户名，而查询要求按用户名对结果进行排序。这意味着 MongoDB 需要在返回结果之前在内存中对结果进行排序，而不是简单地遍历已经按需排好序的索引。因此，这种类型的查询通常效率较低。 
    - ⏱ 2023-10-26 20:42:47 

- 📌 这样非常好，因为不需要在内存中对大量数据进行排序。不过，它必须扫描整个索引以找到所有匹配项。在设计复合索引时，将排序键放在第一位通常是一个好策略。 
    - ⏱ 2023-10-26 20:42:11 

- 📌 当在查询计划中看到 "SORT" 阶段时，意味着 MongoDB 将无法使用索引对数据库中的结果集进行排序，而必须执行内存排序： 
    - ⏱ 2023-10-26 21:14:05 

- 📌 然而，我们真正希望看到的是 "nReturned" 与 "totalKeysExamined" 非常接近。此外，为了更有效地执行此查询，我们希望可以不使用 hint。解决这两个问题的方法是设计一个更好的索引。 
    - ⏱ 2023-10-26 21:15:47 

- 📌 虽然不是所有数据集都这样，但通常在设计复合索引时，应该将等值过滤字段排在多值过滤字段之前。 
    - ⏱ 2023-10-26 21:17:03 

- 📌 在考虑复合索引的设计时，需要知道对于利用索引的通用查询模式，如何处理其等值过滤、多值过滤以及排序这些部分。对于所有复合索引都必须考虑这 3 个因素，而且如果在设计索引时可以正确地平衡这些关注点，那么你的查询就会从 MongoDB 中获得最佳的性能 
    - ⏱ 2023-10-26 21:17:36 

- 📌 > db.students.createIndex({class_id:1, final_grade:1, student_id:1})现在，再次执行这个查询：> db.students.find({student_id:{$gt:500000}, class_id:54})￼ ...          .sort({final_grade:1})￼ ...          .explain("executionStats") 
    - ⏱ 2023-10-26 21:18:58 

- 📌 概括来说，在设计复合索引时：•  等值过滤的键应该在最前面；•  用于排序的键应该在多值字段之前；•  多值过滤的键应该在最后面。 
    - ⏱ 2023-10-26 21:19:07 

- 📌 只有基于多个查询条件进行排序时，索引方向才是重要的。如果只是基于一个键进行排序，那么 MongoDB 可以简单地从相反方向读取索引。如果有一个在 {"age" : -1} 上的排序和基于 {"age" : 1} 的索引，那么 MongoDB 会在使用索引时进行优化，就如同存在一个 {"age" : -1} 索引一样。（所以不要两个都创建！）只有在基于多键排序时，方向才重要。 
    - ⏱ 2023-10-26 21:28:46 

- 📌 如果对一个被覆盖的查询运行 explain，那么结果中会有一个并不处于 "FETCH" 阶段之下的 "IXSCAN" 阶段，并且在 "executionStats" 中，"totalDocsExamined" 的值是 0。 
    - ⏱ 2023-10-26 21:29:01 
## 5.2 explain输出

## 5.3 何时不使用索引

## 5.4 索引类型

## 5.5 索引管理

## 第 6 章 特殊的索引和集合类型

## 6.1 地理空间索引

## 6.2 全文搜索索引

## 6.3 固定集合

## 6.4 TTL索引

## 6.5 使用GridFS存储文件

## 第 7 章 聚合框架

## 7.1 管道、阶段和可调参数

## 7.2 阶段入门：常见操作

## 7.3 表达式

## 7.4 $project

## 7.5 $unwind

## 7.6 数组表达式

## 7.7 累加器

## 7.8 分组简介

## 7.9 将聚合管道结果写入集合中

## 第 8 章 事务

## 8.1 事务简介

## 8.2 如何使用事务

## 8.3 对应用程序的事务限制进行调优

## 第 9 章 应用程序设计

## 9.1 模式设计注意事项

## 9.2 范式化与反范式化

## 9.3 优化数据操作

## 9.4 数据库和集合的设计

## 9.5 一致性管理

## 9.6 模式迁移

## 9.7 模式管理

## 9.8 不适合使用MongoDB的场景

## 第三部分 复制

## 10.1 复制简介

## 10.2 建立副本集（一）

## 10.3 网络注意事项

## 10.4 安全注意事项

## 10.5 建立副本集（二）

## 10.6 观察副本集

## 10.7 更改副本集配置

## 10.8 如何设计副本集

## 10.9 成员配置选项

## 第 11 章 副本集的组成

## 11.1 同步

## 11.2 心跳

## 11.3 选举

## 11.4 回滚

## 第 12 章 从应用程序连接副本集

## 12.1 客户端到副本集的连接行为

## 12.2 在写入时等待复制

## 12.3 自定义复制保证规则

## 12.4 将读请求发送到从节点

## 第 13 章 管理

## 13.1 以单机模式启动成员

## 13.2 副本集配置

## 13.3 控制成员状态

## 13.4 监控复制

## 第四部分 分片

## 14.1 什么是分片

## 14.2 理解集群组件

## 14.3 在单机集群上进行分片

## 第 15 章 配置分片

## 15.1 何时分片

## 15.2 启动服务器

## 15.3 MongoDB如何追踪集群数据

## 15.4 均衡器

## 15.5 排序规则

## 15.6 变更流

## 第 16 章 选择片键

## 16.1 评估使用情况

## 16.2 描绘分发情况

## 16.3 片键策略

## 16.4 片键规则和指导方针

## 16.5 控制数据分发

## 第 17 章 分片管理

## 17.1 查看当前状态

## 17.2 跟踪网络连接

## 17.3 服务器管理

## 17.4 数据均衡

## 第五部分 应用程序管理

## 18.1 查看当前操作

## 18.2 使用系统分析器

## 18.3 计算大小

## 18.4 使用mongotop和mongostat

## 第 19 章 MongoDB 安全介绍

## 19.1 MongoDB的身份验证和授权

## 19.2 MongoDB的认证和传输层加密教程

## 第 20 章 持久性

## 20.1 使用日志机制的成员级别持久性

## 20.2 使用写关注的集群级别持久性

## 20.3 使用读关注的集群级别持久性

## 20.4 使用写关注的事务持久性

## 20.5 MongoDB不能保证什么

## 20.6 检查数据损坏

## 第六部分 服务器端管理

## 21.1 从命令行启动

## 21.2 停止MongoDB

## 21.3 安全性

## 21.4 日志

## 第 22 章 监控 MongoDB

## 22.1 监控内存使用情况

## 22.2 计算工作集的大小

## 22.3 跟踪性能情况

## 22.4 跟踪剩余空间

## 22.5 监控复制情况

## 第 23 章 备份

## 23.1 备份方法

## 23.2 对服务器进行备份

## 23.3 副本集的特殊注意事项

## 23.4 分片集群的特殊注意事项

## 第 24 章 部署 MongoDB

## 24.1 系统设计

## 24.2 虚拟化

## 24.3 配置系统设置

## 24.4 网络配置

## 24.5 系统管理

## 附录 A 安装 MongoDB

## A.1 选择版本

## A.2 在Windows系统中安装

## A.3 在POSIX系统（Linux和Mac OS X）中安装

## 附录 B 深入 MongoDB

## B.1 BSON

## B.2 线路协议

## B.3 数据文件

## B.4 命名空间

## B.5 WiredTiger存储引擎

## 关于作者

## 关于封面

## 看完了


# 读书笔记

## 5.1 索引简介

### 划线评论
- 📌 。例如，"username" 上的索引对下面这种排序就没什么帮助：
> db.users.find().sort({"age" : 1, "username" : 1})  ^225207353-7M1wJR5dP
    - 💭 最左匹配
    - ⏱ 2023-10-17 09:10:34
   

# 本书评论
