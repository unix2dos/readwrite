---
doc_type: weread-highlights-reviews
bookId: CB_FVJ3FZ3DYG5d6lZ6ki8gsFjf
author: 七牛容器云团队
cover: https://res.weread.qq.com/wrepub/CB_7evDWHDX66Nw6ia6gZ9oPCvS_parsecover
reviewCount: 0
noteCount: 6
isbn: 
title: 《Kubernetes_in_Action中文版_博文视点图书_七牛容器_Z_Library-1》
date: 2024-01-11
---

---

![ Kubernetes_in_Action中文版_博文视点图书_七牛容器_Z_Library-1|200](https://res.weread.qq.com/wrepub/CB_7evDWHDX66Nw6ia6gZ9oPCvS_parsecover)


## 首章

## 扉页

## 版权信息

## 推荐序

## 译者序

## 前言

## 致谢

## 关于本书

## 关于作者

## 关于封面插画

## 目录

## 1 Kubernetes介绍

## 1.1 Kubernetes系统的需求


- 📌 因为每个微服务都是独⽴的进程，提供相对静态的API，所以独⽴开发和部署单个微服务成了可能。只要API不变或者向前兼容，改动⼀个微服务，并不会要求对其他微服务进⾏改动或者重新部署。 
    - ⏱ 2024-01-09 19:42:47 
## 1.1.2 为应用程序提供一个一致的环境

## 1.1.3 迈向持续交付：DevOps和无运维

## 1.2 介绍容器技术


- 📌 ⼀个容器⾥运⾏的进程实际上运⾏在宿主机的操作系统上，就像所有其他进程⼀样（不像虚拟机，进程是运⾏在不同的操作系统上的）。但在容器⾥的进程仍然是和其他进程隔离的。对于容器内进程本⾝⽽⾔，就好像是在机器和操作系统上运⾏的唯⼀⼀个进程。 
    - ⏱ 2024-01-11 22:34:40 

- 📌 虚拟机的主要好处是它们提供完全隔离的环境，因为每个虚拟机运⾏在它⾃⼰的Linux内核上，⽽容器都是调⽤同⼀个内核，这⾃然会有安全隐患。如果你的硬件资源有限，那当你有少量进程需要隔离的时候，虚拟机就可以成为⼀个选项。为了在同⼀台机器上运⾏⼤量被隔离的进程，容器因它的低消耗⽽成为⼀个更好的选择。记住，每个虚拟机运⾏它⾃⼰的⼀组系统服务，⽽容器则不会，因为它们都运⾏在同⼀个操作系统上。那也就意味着运⾏⼀个容器不⽤像虚拟机那样要开机，它的进程可以很快被启动。 
    - ⏱ 2024-01-09 19:44:50 

- 📌 那容器到底是怎样隔离它们的。有两个机制可⽤：第⼀个是Linux命名空间，它使每个进程只看到它⾃⼰的系统视图（⽂件、进程、⽹络接⼜、主机名等）；第⼆个是Linux控制组（cgroups），它限制了进程能使⽤的资源量（CPU、内存、⽹络带宽等）。 
    - ⏱ 2024-01-11 22:36:12 
## 1.2.2 Docker容器平台介绍


- 📌 cgroups是⼀个Linux内核功能，它被⽤来限制⼀个进程或者⼀组进程的资源使⽤。⼀个进程的资源（CPU、内存、⽹络带宽等）使⽤量不能超出被分配的量。这种⽅式下，进程不能过分使⽤为其他进程保留的资源，这和进程运⾏在不同的机器上是类似的 
    - ⏱ 2024-01-11 22:37:14 

- 📌 理论上，⼀个容器镜像能运⾏在任何⼀个运⾏Docker的机器上。但有⼀个⼩警告——⼀个关于运⾏在⼀台机器上的所有容器共享主机 Linux内核的警告。如果⼀个容器化的应⽤需要⼀个特定的内核版本，那它可能不能在每台机器上都⼯作。如果⼀台机器上运⾏了⼀个不匹配的Linux内核版本，或者没有相同内核模块可⽤，那么此应⽤就不能在其上运⾏。 
    - ⏱ 2024-01-11 22:39:32 
## 1.2.3 rkt——一个Docker的替代方案

## 1.3 Kubernetes介绍

## 1.3.3 Kubernetes集群架构

## 1.3.4 在Kubernetes中运行应用

## 1.3.5 使用Kubernetes的好处

## 1.4 本章小结

## 2 开始使用Kubernetes和Docker

## 2.1 创建、运行及共享容器镜像

## 2.1.2 创建一个简单的 Node.js 应用

## 2.1.3 为镜像创建Dockerfile

## 2.1.5 运行容器镜像

## 2.1.6 探索运行容器的内部

## 2.1.7 停止和删除容器

## 2.1.8 向镜像仓库推送镜像

## 2.2 配置Kubernetes集群

## 2.2.1 用Minikube运行一个本地单节点Kubernetes集群

## 2.2.2 使用Google Kubernetes Engine托管Kubernetes集群

## 2.2.3 为kubectl配置别名和命令行补齐

## 2.3 在Kubernetes上运行第一个应用

## 2.3.2 访问Web应用

## 2.3.3 系统的逻辑部分

## 2.3.4 水平伸缩应用

## 2.3.5 查看应用运行在哪个节点上

## 2.3.6 介绍Kubernetes dashboard

## 2.4 本章小结

## 3 pod：运行于Kubernetes中的容器

## 3.1 介绍pod

## 3.1.2 了解pod

## 3.1.3 通过pod合理管理容器

## 3.2 以YAML或JSON描述文件创建pod

## 3.2.2 为pod创建一个简单的YAML描述文件

## 3.2.3 使用kubectl create来创建pod

## 3.2.4 查看应用程序日志

## 3.2.5 向pod发送请求

## 3.3 使用标签组织pod

## 3.3.1 介绍标签

## 3.3.2 创建pod时指定标签

## 3.3.3 修改现有pod的标签

## 3.4 通过标签选择器列出pod子集

## 3.4.2 在标签选择器中使用多个条件

## 3.5 使用标签和选择器来约束pod调度

## 3.5.2 将pod调度到特定节点

## 3.5.3 调度到一个特定节点

## 3.6 注解pod

## 3.6.2 添加和修改注解

## 3.7 使用命名空间对资源进行分组

## 3.7.2 发现其他命名空间及其pod

## 3.7.3 创建一个命名空间

## 3.7.4 管理其他命名空间中的对象

## 3.7.5 命名空间提供的隔离

## 3.8 停止和移除pod

## 3.8.3 通过删除整个命名空间来删除pod

## 3.8.4 删除命名空间中的所有pod，但保留命名空间

## 3.8.5 删除命名空间中的（几乎）所有资源

## 3.9 本章小结

## 4 副本机制和其他控制器：部署托管的pod

## 4.1 保持pod健康

## 4.1.1 介绍存活探针

## 4.1.3 使用存活探针

## 4.1.4 配置存活探针的附加属性

## 4.1.5 创建有效的存活探针

## 4.2 了解ReplicationController

## 4.2.1 ReplicationController的操作

## 4.2.2 创建一个ReplicationController

## 4.2.3 使用ReplicationController

## 4.2.4 将pod移入或移出ReplicationController的作用域

## 4.2.5 修改pod模板

## 4.2.6 水平缩放pod

## 4.2.7 删除一个ReplicationController

## 4.3 使用ReplicaSet而不是ReplicationController

## 4.3.2 定义ReplicaSet

## 4.3.3 创建和检查ReplicaSet

## 4.3.4 使用ReplicaSet的更富表达力的标签选择器

## 4.3.5 ReplicaSet小结

## 4.4 使用DaemonSet在每个节点上运行一个pod

## 4.4.1 使用DaemonSet在每个节点上运行一个pod

## 4.5 运行执行单个任务的pod

## 4.5.2 定义Job资源

## 4.5.3 看Job运行一个pod

## 4.5.4 在Job中运行多个pod实例

## 4.5.5 限制Job pod完成任务的时间

## 4.6 安排Job定期运行或在将来运行一次

## 4.6.2 了解计划任务的运行方式

## 4.7 本章小结

## 5 服务：让客户端发现pod并与之通信

## 5.1 介绍服务

## 5.1.1 创建服务

## 5.1.2 服务发现

## 5.2 连接集群外部的服务

## 5.2.2 手动配置服务的endpoint

## 5.2.3 为外部服务创建别名

## 5.3 将服务暴露给外部客户端

## 5.3.1 使用NodePort类型的服务

## 5.3.2 通过负载均衡器将服务暴露出来

## 5.3.3 了解外部连接的特性

## 5.4 通过Ingress暴露服务

## 5.4.1 创建Ingress资源

## 5.4.2 通过Ingress访问服务

## 5.4.3 通过相同的Ingress暴露多个服务

## 5.4.4 配置Ingress处理TLS传输

## 5.5 pod就绪后发出信号

## 5.5.2 向pod添加就绪探针

## 5.5.3 了解就绪探针的实际作用

## 5.6 使用headless服务来发现独立的pod

## 5.6.2 通过DNS发现pod

## 5.6.3 发现所有的pod——包括未就绪的pod

## 5.7 排除服务故障

## 5.8 本章小结

## 6 卷：将磁盘挂载到容器

## 6.1 介绍卷

## 6.1.2 介绍可用的卷类型

## 6.2 通过卷在容器之间共享数据

## 6.2.2 使用Git 仓库作为存储卷

## 6.3 访问工作节点文件系统上的文件

## 6.3.2 检查使用hostPath卷的系统pod

## 6.4 使用持久化存储

## 6.4.2 通过底层持久化存储使用其他类型的卷

## 6.5 从底层存储技术解耦pod

## 6.5.2 创建持久卷

## 6.5.3 通过创建持久卷声明来获取持久卷

## 6.5.4 在pod中使用持久卷声明

## 6.5.5 了解使用持久卷和持久卷声明的好处

## 6.5.6 回收持久卷

## 6.6 持久卷的动态卷配置

## 6.6.2 请求持久卷声明中的存储类

## 6.6.3 不指定存储类的动态配置

## 6.7 本章小结

## 7 ConfigMap和Secret：配置应用程序

## 7.1 配置容器化应用程序

## 7.2 向容器传递命令行参数

## 7.2.2 在Kubernetes中覆盖命令和参数

## 7.3 为容器设置环境变量

## 7.3.1 在容器定义中指定环境变量

## 7.3.2 在环境变量值中引用其他环境变量

## 7.3.3 了解硬编码环境变量的不足之处

## 7.4 利用ConfigMap解耦配置

## 7.4.2 创建ConfigMap

## 7.4.3 给容器传递ConfigMap条目作为环境变量

## 7.4.4 一次性传递ConfigMap的所有条目作为环境变量

## 7.4.5 传递ConfigMap条目作为命令行参数

## 7.4.6 使用configMap卷将条目暴露为文件

## 7.4.7 更新应用配置且不重启应用程序

## 7.5 使用Secret给容器传递敏感数据

## 7.5.2 默认令牌Secret介绍

## 7.5.3 创建Secret

## 7.5.4 对比ConfigMap与Secret

## 7.5.5 在pod中使用Secret

## 7.6 本章小结

## 8 从应用访问pod元数据以及其他资源

## 8.1 通过Downward API传递元数据

## 8.1.1 了解可用的元数据

## 8.1.2 通过环境变量暴露元数据

## 8.1.3 通过downwardAPI卷来传递元数据

## 8.2 与Kubernetes API服务器交互

## 8.2.2 从pod内部与API服务器进行交互

## 8.2.3 通过ambassador容器简化与API服务器的交互

## 8.2.4 使用客户端库与API服务器交互

## 8.3 本章小结

## 9 Deployment：声明式地升级应用

## 9.1 更新运行在pod内的应用程序

## 9.1.1 删除旧版本pod，使用新版本pod替换

## 9.1.2 先创建新pod再删除旧版本pod

## 9.2 使用ReplicationController实现自动的滚动升级

## 9.2.2 使用kubectl来执行滚动式升级

## 9.2.3 为什么kubectl rolling-update已经过时

## 9.3 使用Deployment声明式地升级应用

## 9.3.1 创建一个Deployment

## 9.3.2 升级Deployment

## 9.3.3 回滚Deployment

## 9.3.4 控制滚动升级速率

## 9.3.5 暂停滚动升级

## 9.3.6 阻止出错版本的滚动升级

## 9.4 本章小结

## 10 StatefulSet：部署有状态的多副本应用

## 10.1 复制有状态pod

## 10.1.2 每个pod都提供稳定的标识

## 10.2 了解Statefulset

## 10.2.2 提供稳定的网络标识

## 10.2.3 为每个有状态实例提供稳定的专属存储

## 10.2.4 Statefulset的保障

## 10.3 使用Statefulset

## 10.3.2 通过Statefulset部署应用

## 10.3.3 使用你的pod

## 10.4 在Statefulset中发现伙伴节点

## 10.4.1 通过DNS实现伙伴间彼此发现

## 10.4.2 更新Statefulset

## 10.4.3 尝试集群数据存储

## 10.5 了解Statefulset如何处理节点失效

## 10.5.2 手动删除pod

## 10.6 本章小结

## 11 了解Kubernetes机理

## 11.1 了解架构

## 11.1.1 Kubernetes组件的分布式特性

## 11.1.2 Kubernetes如何使用etcd

## 11.1.3 API服务器做了什么

## 11.1.4 API服务器如何通知客户端资源变更

## 11.1.5 了解调度器

## 11.1.6 介绍控制器管理器中运行的控制器

## 11.1.7 Kubelet做了什么

## 11.1.8 Kubernetes Service Proxy的作用

## 11.1.9 介绍Kubernetes插件

## 11.1.10 总结概览

## 11.2 控制器如何协作

## 11.2.3 观察集群事件

## 11.3 了解运行中的pod是什么

## 11.4 跨pod网络

## 11.4.2 深入了解网络工作原理

## 11.4.3 引入容器网络接口

## 11.5 服务是如何实现的

## 11.6 运行高可用集群

## 11.6.2 让Kubernetes控制平面变得高可用

## 11.7 本章小结

## 12 Kubernetes API服务器的安全防护

## 12.1 了解认证机制

## 12.1.2 ServiceAccount介绍

## 12.1.3 创建ServiceAccount

## 12.1.4 将ServiceAccount分配给pod

## 12.2 通过基于角色的权限控制加强集群安全

## 12.2.2 介绍RBAC资源

## 12.2.3 使用Role和RoleBinding

## 12.2.4 使用ClusterRole和ClusterRoleBinding

## 12.2.5 了解默认的ClusterRole和ClusterRoleBinding

## 12.2.6 理性地授予授权权限

## 12.3 本章小结

## 13 保障集群内节点和网络安全

## 13.1 在pod中使用宿主节点的Linux命名空间

## 13.1.2 绑定宿主节点上的端口而不使用宿主节点的网络命名空间

## 13.1.3 使用宿主节点的PID与IPC命名空间

## 13.2 配置节点的安全上下文

## 13.2.1 使用指定用户运行容器

## 13.2.2 阻止容器以root用户运行

## 13.2.3 使用特权模式运行pod

## 13.2.4 为容器单独添加内核功能

## 13.2.5 在容器中禁用内核功能

## 13.2.6 阻止对容器根文件系统的写入

## 13.2.7 容器使用不同用户运行时共享存储卷

## 13.3 限制pod使用安全相关的特性

## 13.3.2 了解runAsUser、fsGroup和supplementalGroup策略

## 13.3.3 配置允许、默认添加、禁止使用的内核功能

## 13.3.4 限制pod可以使用的存储卷类型

## 13.3.5 对不同的用户与组分配不同的PodSecurityPolicy

## 13.4 隔离pod的网络

## 13.4.2 允许同一命名空间中的部分pod访问一个服务端pod

## 13.4.3 在不同Kubernetes命名空间之间进行网络隔离

## 13.4.4 使用CIDR隔离网络

## 13.4.5 限制pod的对外访问流量

## 13.5 本章小结

## 14 计算资源管理

## 14.1 为pod中的容器申请资源

## 14.1.2 资源requests如何影响调度

## 14.1.3 CPU requests如何影响CPU时间分配

## 14.1.4 定义和申请自定义资源

## 14.2 限制容器的可用资源

## 14.2.2 超过limits

## 14.2.3 容器中的应用如何看待limits

## 14.3 了解pod QoS等级

## 14.3.2 内存不足时哪个进程会被杀死

## 14.4 为命名空间中的pod设置默认的requests和limits

## 14.4.2 LimitRange对象的创建

## 14.4.3 强制进行限制

## 14.4.4 应用资源requests和limits的默认值

## 14.5 限制命名空间中的可用资源总量

## 14.5.2 为持久化存储指定配额

## 14.5.3 限制可创建对象的个数

## 14.5.4 为特定的pod状态或者QoS等级指定配额

## 14.6 监控pod的资源使用量

## 14.6.2 保存并分析历史资源的使用统计信息

## 14.7 本章小结

## 15 自动横向伸缩pod与集群节点

## 15.1 pod的横向自动伸缩

## 15.1.2 基于CPU使用率进行自动伸缩

## 15.1.3 基于内存使用进行自动伸缩

## 15.1.5 确定哪些度量适合用于自动伸缩

## 15.1.6 缩容到0个副本

## 15.2 pod的纵向自动伸缩

## 15.3 集群节点的横向伸缩

## 15.3.2 启用Cluster Autoscaler

## 15.3.3 限制集群缩容时的服务干扰

## 15.4 本章小结

## 16 高级调度

## 16.1 使用污点和容忍度阻止节点调度到特定节点

## 16.1.2 在节点上添加自定义污点

## 16.1.3 在pod上添加污点容忍度

## 16.1.4 了解污点和污点容忍度的使用场景

## 16.2 使用节点亲缘性将pod调度到特定节点上

## 16.2.1 指定强制性节点亲缘性规则

## 16.2.2 调度pod时优先考虑某些节点

## 16.3 使用pod亲缘性与非亲缘性对pod进行协同部署

## 16.3.2 将pod部署在同一机柜、可用性区域或者地理地域

## 16.3.3 表达pod亲缘性优先级取代强制性要求

## 16.3.4 利用pod的非亲缘性分开调度pod

## 16.4 本章小结

## 17 开发应用的最佳实践

## 17.1 集中一切资源

## 17.2 了解pod的生命周期

## 17.2.2 重新调度死亡的或者部分死亡的pod

## 17.2.3 以固定顺序启动pod

## 17.2.4 增加生命周期钩子

## 17.2.5 了解pod的关闭

## 17.3 确保所有的客户端请求都得到了妥善处理

## 17.3.2 在pod关闭时避免客户端连接断开

## 17.4 让应用在Kubernetes中方便运行和管理

## 17.4.2 合理地给镜像打标签，正确地使用ImagePullPolicy

## 17.4.4 通过注解描述每个资源

## 17.4.6 处理应用日志

## 17.5 开发和测试的最佳实践

## 17.5.2 在开发过程中使用Minikube

## 17.5.3 发布版本和自动部署资源清单

## 17.5.4 使用Ksonnet作为编写YAML/JSON manifest文件的额外选择

## 17.5.5 利用持续集成和持续交付

## 17.6 本章小结

## 18 Kubernetes应用扩展

## 18.1 定义自定义API对象

## 18.1.2 使用自定义控制器自动定制资源

## 18.1.3 验证自定义对象

## 18.1.4 为自定义对象提供自定义API服务器

## 18.2 使用Kubernetes服务目录扩展Kubernetes

## 18.2.2 服务目录API服务器与控制器管理器介绍

## 18.2.3 Service代理和OpenServiceBroker API

## 18.2.4 提供服务与使用服务

## 18.2.5 解除绑定与取消配置

## 18.2.6 服务目录给我们带来了什么

## 18.3 基于Kubernetes搭建的平台

## 18.3.2 Deis Workfiow与Helm

## 18.4 本章小结

## A 在多个集群中使用kubectl

## B 使用kubeadm配置多节点集群

## C 使用其他容器运行时

## D Cluster Federation


# 读书笔记


# 本书评论
