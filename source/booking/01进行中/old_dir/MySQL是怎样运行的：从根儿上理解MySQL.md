---
doc_type: weread-highlights-reviews
bookId: CB_DNhGZtGYWAJq6is6gbACk93M
author: 
cover: https://res.weread.qq.com/wrepub/CB_EsC8gC8hnBzr6T96U7_parsecover
reviewCount: 0
noteCount: 10
readingStatus: 未标记
progress: undefined%
totalReadDay: 2
readingTime: 0小时29分钟
readingDate: 2023-09-05
isbn: 
title: 《MySQL是怎样运行的：从根儿上理解MySQL》
date: 2023-09-05

---

![ MySQL是怎样运行的：从根儿上理解MySQL|200](https://res.weread.qq.com/wrepub/CB_EsC8gC8hnBzr6T96U7_parsecover)


### 0.3 关于工具


- 📌 还有各位写博客的同学，引用的少了叫借鉴，引用的多了就，就有点那个了。希望各位不要大段大段的复制粘贴，用自己的话写出来的知识才是自己的东西。 
    - ⏱ 2023-09-05 18:21:16 
### 3.1 字符集和比较规则简介


- 📌 对于同一个字符，不同字符集也可能有不同的编码方式。比如对于汉字 '我' 来说， ASCII 字符集中根本没有收录这个字符， utf8 和 gb2312 字符集对汉字 我 的编码方式如下：
utf8编码：111001101000100010010001 (3个字节，十六进制表示是：0xE68891) gb2312编码：1100111011010010 (2个字节，十六进制表示是：0xCED2) 
    - ⏱ 2023-09-05 18:25:24 
### 3.2 MySQL中支持的字符集和排序规则


- 📌 我们上边说 utf8 字符集表示一个字符需要使用1～4个字节，但是我们常用的一些字符使用1～3个字节就可以表示了。而在 MySQL 中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，所以设计 MySQL 的大叔偷偷的定义了两个概念：
utf8mb3 ：阉割过的 utf8 字符集，只使用1～3个字节表示字符。utf8mb4 ：正宗的 utf8 字符集，使用1～4个字节表示字符。
有一点需要大家十分的注意，在 MySQL 中 utf8 是 utf8mb3 的别名，所以之后在 MySQL 中提到 utf8 就意味着使用1~3个字节来表示一个字符，如果大家有使用4字节编码一个字符的情况，比如存储一些emoji表情啥的，那请使用 utf8mb4 。 
    - ⏱ 2023-09-05 18:25:53 
### 3.3 字符集和比较规则的应用


- 📌 比较规则名称以与其关联的字符集的名称开头。如上图的查询结果的比较规则名称都是以 utf8 开头的。后边紧跟着该比较规则主要作用于哪种语言，比如 utf8_polish_ci 表示以波兰语的规则比较，utf8_spanish_ci 是以西班牙语的规则比较， utf8_general_ci 是一种通用的比较规则。 
    - ⏱ 2023-09-05 18:31:49 

- 📌 比如 utf8_general_ci 这个比较规则是以 ci 结尾的，说明不区分大小写。 
    - ⏱ 2023-09-05 18:32:02 
#### 3.3.1 各级别的字符集和比较规则


- 📌 可以看到在我的计算机中服务器级别默认的字符集是 utf8 ，默认的比较规则是 utf8_general_ci 。 
    - ⏱ 2023-09-05 18:27:42 

- 📌 由于字符集和比较规则是互相有联系的，如果我们只修改了字符集，比较规则也会跟着变化，如果只修改了比较规则，字符集也会跟着变化，具体规则如下：
只修改字符集，则比较规则将变为修改后的字符集默认的比较规则。只修改比较规则，则字符集将变为修改后的比较规则对应的字符集。 
    - ⏱ 2023-09-05 18:29:13 
#### 7.3.1 覆盖索引


- 📌 只为用于搜索、排序或分组的列创建索引
也就是说，只为出现在 WHERE 子句中的列、连接子句中的连接列，或者出现在 ORDER BY 或 GROUP BY 子句中的列创建索引。而出现在查询列表中的列就没必要建立索引了：
SELECT birthday, country FROM person name WHERE name = 'Ashburn'; 
    - ⏱ 2023-09-05 18:44:54 
#### 7.4.2 考虑列的基数


- 📌 y p _ ;
像查询列表中的 birthday 、 country 这两个列就不需要建立索引，我们只需要为出现在 WHERE 子句中的 name列创建索引就可以了 
    - ⏱ 2023-09-05 18:45:22 
#### 7.4.7 冗余和重复索引


- 📌 KEY idx_name_birthday_phone_number (name(10), birthday, phone_number), KEY idx_name (name(10)) );
我们知道，通过 idx_name_birthday_phone_number 索引就可以对 name 列进行快速搜索，再创建一个专门针对 name 列的索引就算是一个 冗余 索引，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。 
    - ⏱ 2023-09-05 18:46:40 

# 读书笔记


# 本书评论
