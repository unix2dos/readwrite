---
doc_type: weread-highlights-reviews
bookId: CB_DNhGZtGYWAJq6is6gbACk93M
author: 
cover: https://res.weread.qq.com/wrepub/CB_EsC8gC8hnBzr6T96U7_parsecover
reviewCount: 0
noteCount: 10
isbn: 
title: 《MySQL是怎样运行的：从根儿上理解MySQL》
date: 2023-09-05
---

---


## 0 第0章 万里长征第一步（非常重要）-如何愉快的阅读本小册

## 0.3 关于工具


- 📌 还有各位写博客的同学，引用的少了叫借鉴，引用的多了就，就有点那个了。希望各位不要大段大段的复制粘贴，用自己的话写出来的知识才是自己的东西。 
    - ⏱ 2023-09-05 18:21:16 
## 0.6 关于转发

## 1.2 MySQL的安装

## 1.3 启动MySQL服务器程序

## 1.4 启动MySQL客户端程序

## 1.4.1 连接注意事项

## 1.5 客户端与服务器连接的过程

## 1.5.2 命名管道和共享内存

## 1.6.1 连接管理

## 1.6.3 存储引擎

## 1.7 常用存储引擎

## 1.8 关于存储引擎的一些操作

## 1.8.2 设置表的存储引擎

## 2 第2章 MySQL的调控按钮-启动选项和系统变量

## 2.1 在命令行上使用选项

## 2.1.1 选项的长形式和短形式

## 2.2.2 配置文件的内容

## 2.2.3 特定MySQL版本的专用选项组

## 2.2.6 defaults-file的使用

## 2.4.3 设置系统变量

## 2.4.4 启动选项和系统变量的区别

## 3.1 字符集和比较规则简介


- 📌 对于同一个字符，不同字符集也可能有不同的编码方式。比如对于汉字 '我' 来说， ASCII 字符集中根本没有收录这个字符， utf8 和 gb2312 字符集对汉字 我 的编码方式如下：utf8编码：111001101000100010010001 (3个字节，十六进制表示是：0xE68891) gb2312编码：1100111011010010 (2个字节，十六进制表示是：0xCED2) 
    - ⏱ 2023-09-05 18:25:24 
## 3.2 MySQL中支持的字符集和排序规则


- 📌 我们上边说 utf8 字符集表示一个字符需要使用1～4个字节，但是我们常用的一些字符使用1～3个字节就可以表示了。而在 MySQL 中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，所以设计 MySQL 的大叔偷偷的定义了两个概念：utf8mb3 ：阉割过的 utf8 字符集，只使用1～3个字节表示字符。utf8mb4 ：正宗的 utf8 字符集，使用1～4个字节表示字符。有一点需要大家十分的注意，在 MySQL 中 utf8 是 utf8mb3 的别名，所以之后在 MySQL 中提到 utf8 就意味着使用1~3个字节来表示一个字符，如果大家有使用4字节编码一个字符的情况，比如存储一些emoji表情啥的，那请使用 utf8mb4 。 
    - ⏱ 2023-09-05 18:25:53 
## 3.2.3 比较规则的查看

## 3.3 字符集和比较规则的应用


- 📌 比较规则名称以与其关联的字符集的名称开头。如上图的查询结果的比较规则名称都是以 utf8 开头的。后边紧跟着该比较规则主要作用于哪种语言，比如 utf8_polish_ci 表示以波兰语的规则比较，utf8_spanish_ci 是以西班牙语的规则比较， utf8_general_ci 是一种通用的比较规则。 
    - ⏱ 2023-09-05 18:31:49 

- 📌 比如 utf8_general_ci 这个比较规则是以 ci 结尾的，说明不区分大小写。 
    - ⏱ 2023-09-05 18:32:02 
## 3.3.1 各级别的字符集和比较规则


- 📌 可以看到在我的计算机中服务器级别默认的字符集是 utf8 ，默认的比较规则是 utf8_general_ci 。 
    - ⏱ 2023-09-05 18:27:42 

- 📌 由于字符集和比较规则是互相有联系的，如果我们只修改了字符集，比较规则也会跟着变化，如果只修改了比较规则，字符集也会跟着变化，具体规则如下：只修改字符集，则比较规则将变为修改后的字符集默认的比较规则。只修改比较规则，则字符集将变为修改后的比较规则对应的字符集。 
    - ⏱ 2023-09-05 18:29:13 
## 3.3.2 客户端和服务器通信中的字符集

## 3.3.3 比较规则的应用

## 3.4 总结

## 4 第4章 从一条记录说起-InnoDB记录结构

## 4.3 InnoDB行格式

## 4.3.2 COMPACT行格式

## 4.3.3 Redundant行格式

## 4.3.4 行溢出数据

## 4.3.5 Dynamic和Compressed行格式

## 5 第5章 盛放记录的大盒子-InnoDB数据页结构

## 5.3 记录在页中的存储

## 5.3.1 记录头信息的秘密

## 5.4 Page Directory（页目录）

## 5.5 Page Header（页面头部）

## 5.6 File Header（文件头部）

## 5.7 File Trailer

## 6 第6章 快速查询的秘籍-B+树索引

## 6.1.2 在很多页中查找

## 6.2.1 一个简单的索引方案

## 6.2.2 InnoDB中的索引方案

## 6.2.3 InnoDB的B+树索引的注意事项

## 6.2.4 MyISAM中的索引方案简单介绍

## 6.2.5 MySQL中创建和删除索引的语句

## 7.1 索引的代价

## 7.2.1 全值匹配

## 7.2.2 匹配左边的列

## 7.2.4 匹配范围值

## 7.2.6 用于排序

## 7.2.7 用于分组

## 7.3.1 覆盖索引


- 📌 只为用于搜索、排序或分组的列创建索引也就是说，只为出现在 WHERE 子句中的列、连接子句中的连接列，或者出现在 ORDER BY 或 GROUP BY 子句中的列创建索引。而出现在查询列表中的列就没必要建立索引了：SELECT birthday, country FROM person name WHERE name = 'Ashburn'; 
    - ⏱ 2023-09-05 18:44:54 
## 7.4.2 考虑列的基数


- 📌 y p _ ;像查询列表中的 birthday 、 country 这两个列就不需要建立索引，我们只需要为出现在 WHERE 子句中的 name列创建索引就可以了 
    - ⏱ 2023-09-05 18:45:22 
## 7.4.5 让索引列在比较表达式中单独出现

## 7.4.7 冗余和重复索引


- 📌 KEY idx_name_birthday_phone_number (name(10), birthday, phone_number), KEY idx_name (name(10)) );我们知道，通过 idx_name_birthday_phone_number 索引就可以对 name 列进行快速搜索，再创建一个专门针对 name 列的索引就算是一个 冗余 索引，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。 
    - ⏱ 2023-09-05 18:46:40 
## 7.5 总结

## 8.2.1 数据目录和安装目录的区别

## 8.3.2 表在文件系统中的表示

## 8.3.3 视图在文件系统中的表示

## 9 第9章 存放页面的大池子-InnoDB的表空间

## 9.1.2 页面通用部分

## 9.2 独立表空间结构

## 9.2.2 段（segment）的概念

## 9.2.3 区的分类

## 9.2.4 段的结构

## 9.2.5 各类型页面详细情况

## 9.2.6 Segment Header 结构的运用

## 9.2.7 真实表空间对应的文件大小

## 9.3.2 总结图

## 10 第10章 条条大路通罗马-单表访问方法

## 10.1 访问方法（access method）的概念

## 10.2 const

## 10.3 ref

## 10.4 ref_or_null

## 10.6 index

## 10.8.1 重温 二级索引 + 回表

## 10.8.3 索引合并

## 11 第11章 两个表的亲密接触-连接的原理

## 11.1.2 连接过程简介

## 11.1.3 内连接和外连接

## 11.2 连接的原理

## 11.2.2 使用索引加快连接速度

## 11.2.3 基于块的嵌套循环连接（Block Nested-Loop Join）

## 12 第12章 谁最便宜就选谁-MySQL基于成本的优化

## 12.1 什么是成本

## 12.2.3 基于索引统计数据的成本计算

## 12.3 连接查询的成本

## 12.3.3 两表连接的成本分析

## 12.3.4 多表连接的成本分析

## 12.4.1 mysql.server_cost表

## 12.4.2 mysql.engine_cost表

## 13 第13章 兵马未动，粮草先行-InnoDB统计数据是如何收集的

## 13.2.1 innodb_table_stats

## 13.2.2 innodb_index_stats

## 13.2.3 定期更新统计数据

## 和

## 13.4 innodb_stats_method的使用

## 13.5 总结

## 14.1.3 等值传递（equality_propagation）

## 14.1.6 HAVING子句和WHERE子句的合并

## 14.3 子查询优化

## 14.3.2 子查询在MySQL中是怎么执行的

## 15 第15章 查询优化的百科全书-Explain详解（上）

## 15.1 执行计划输出中各列详解

## 15.1.2 id

## 15.1.3 select_type

## 15.1.4 partitions

## 15.1.6 possible_keys和key

## 15.1.7 key_len

## 15.1.8 ref

## 15.1.9 rows

## 16 第16章 查询优化的百科全书-Explain详解（下）

## 16.2 Json格式的执行计划

## 16.3 Extented EXPLAIN

## 17 第17章 神兵利器-optimizer trace表的神器功效

## 18 第18章 调节磁盘和CPU的矛盾-InnoDB的Buffer Pool

## 18.1 缓存的重要性

## 18.2.3 free链表的管理

## 18.2.4 缓存页的哈希处理

## 18.2.6 LRU链表的管理

## 18.2.7 其他的一些链表

## 18.2.10 innodb_buffer_pool_chunk_size

## 18.2.11 配置Buffer Pool时的注意事项

## 18.2.12 Buffer Pool中存储的其它信息

## 18.3 总结

## 19 第19章 从猫爷被杀说起-事务简介

## 19.1.1 原子性（Atomicity）

## 19.1.3 一致性（Consistency）

## 19.1.4 持久性（Durability）

## 19.3 MySQL中事务的语法

## 19.3.2 提交事务

## 19.3.3 手动中止事务

## 19.3.5 自动提交

## 19.3.7 保存点

## 20 第20章 说过的话就一定要办到-redo日志（上）

## 20.1 事先说明

## 20.3.1 简单的redo日志类型

## 20.3.2 复杂一些的redo日志类型

## 20.3.3 redo日志格式小结

## 20.4.2 Mini-Transaction的概念

## 20.5 redo日志的写入过程

## 20.5.2 redo日志缓冲区

## 21 第21章 说过的话就一定要办到-redo日志（下）

## 21.1.2 redo日志文件组

## 21.2 Log Sequeue Number

## 21.2.1 flushed_to_disk_lsn

## 21.2.2 lsn值和redo日志文件偏移量的对应关系

## 21.3 checkpoint

## 21.3.1 批量从flush链表中刷出脏页

## 21.4 innodb_flush_log_at_trx_commit的用法

## 21.5.2 确定恢复的终点

## 21.6 遗漏的问题：LOG_BLOCK_HDR_NO是如何计算的

## 22 第22章 后悔了怎么办-undo日志（上）

## 22.2 事务id

## 22.2.3 trx_id隐藏列

## 22.3.1 INSERT操作对应的undo日志

## 22.3.2 DELETE操作对应的undo日志

## 22.3.3 UPDATE操作对应的undo日志

## 23 第23章 后悔了怎么办-undo日志（下）

## 23.2 FIL_PAGE_UNDO_LOG页面

## 23.3 Undo页面链表

## 23.3.2 多个事务中的Undo页面链表

## 23.4 undo日志具体写入过程

## 23.4.2 Undo Log Segment Header

## 23.4.3 Undo Log Header

## 23.4.4 小结

## 23.6 回滚段

## 23.6.2 从回滚段中申请Undo页面链表

## 23.6.3 多个回滚段

## 23.6.4 回滚段的分类

## 23.6.5 为事务分配Undo页面链表详细过程

## 23.7 回滚段相关配置

## 24.1 事前准备

## 24.2.2 SQL标准中的四种隔离级别

## 24.3 MVCC原理

## 24.3.2 ReadView

## 24.3.3 MVCC小结

## 25.1.1 一致性读（Consistent Reads）

## 25.1.3 写操作

## 25.3 MySQL中的行锁和表锁

## 25.3.2 InnoDB存储引擎中的锁

## 25.3.3 InnoDB锁的内存结构

## 25.4 更多内容

## 26.1.2 一些书籍

## 26.1.3 说点不好的


# 读书笔记


# 本书评论
