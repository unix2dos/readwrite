---
doc_type: weread-highlights-reviews
bookId: "26562837"
author: 黄健宏
cover: https://cdn.weread.qq.com/weread/cover/59/YueWen_26562837/t7_YueWen_26562837.jpg
reviewCount: 1
noteCount: 16
isbn: 9787111636526
title: 《Redis使用手册》
date: 2023-09-06
---

---


## 封面

## 版权信息

## 前言

## 第1章 引言

## 1.1 Redis简介

## 1.2 内容编排

## 1.3 目标读者

## 1.4 预备工作

## 1.5 执行命令

## 1.6 配置服务器

## 1.7 示例代码

## 1.8 版本说明

## 1.9 读者服务网站

## 1.10 启程

## 01第一部分 数据结构与应用

## 2.1 SET：为字符串键设置值

## 2.2 GET：获取字符串键的值

## 2.3 GETSET：获取旧值并设置新值

## 示例：缓存

## 示例：锁

## 2.4 MSET：一次为多个字符串键设置值

## 2.5 MGET：一次获取多个字符串键的值

## 2.6 MSETNX：只在键不存在的情况下，一次为多个字符串键设置值

## 示例：存储文章信息

## 2.7 STRLEN：获取字符串值的字节长度

## 2.8 字符串值的索引

## 2.9 GETRANGE：获取字符串值指定索引范围上的内容

## 2.10 SETRANGE：对字符串值的指定索引范围进行设置

## 示例：给文章存储程序加上文章长度计数功能和文章预览功能

## 2.11 APPEND：追加新内容到值的末尾

## 示例：存储日志

## 2.12 使用字符串键存储数字值

## 2.13 INCRBY、DECRBY：对整数值执行加法操作和减法操作

## 2.14 INCR、DECR：对整数值执行加1操作和减1操作

## 2.15 INCRBYFLOAT：对数字值执行浮点数加法操作

## 示例：ID生成器

## 示例：计数器

## 示例：限速器

## 2.16 重点回顾

## 第3章 散列

## 3.1 散列简介

## 3.2 HSET：为字段设置值

## 3.3 HSETNX：只在字段不存在的情况下为它设置值

## 3.4 HGET：获取字段的值

## 示例：实现短网址生成程序

## 3.5 HINCRBY：对字段存储的整数值执行加法或减法操作

## 3.6 HINCRBYFLOAT：对字段存储的数字值执行浮点数加法或减法操作

## 示例：使用散列键重新实现计数器

## 3.7 HSTRLEN：获取字段值的字节长度

## 3.8 HEXISTS：检查字段是否存在

## 3.9 HDEL：删除字段

## 3.10 HLEN：获取散列包含的字段数量

## 示例：实现用户登录会话

## 3.11 HMSET：一次为多个字段设置值

## 3.12 HMGET：一次获取多个字段的值

## 3.13 HKEYS、HVALS、HGETALL：获取所有字段、所有值、所有字段和值

## 示例：存储图数据

## 示例：使用散列键重新实现文章存储程序

## 3.14 散列与字符串

## 3.15 重点回顾

## 第4章 列表

## 4.1 LPUSH：将元素推入列表左端

## 4.2 RPUSH：将元素推入列表右端

## 4.3 LPUSHX、RPUSHX：只对已存在的列表执行推入操作

## 4.4 LPOP：弹出列表最左端的元素

## 4.5 RPOP：弹出列表最右端的元素

## 4.6 RPOPLPUSH：将右端弹出的元素推入左端

## 示例：先进先出队列

## 4.7 LLEN：获取列表的长度

## 4.8 LINDEX：获取指定索引上的元素

## 4.9 LRANGE：获取指定索引范围上的元素

## 示例：分页

## 4.10 LSET：为指定索引设置新元素

## 4.11 LINSERT：将元素插入列表

## 4.12 LTRIM：修剪列表

## 4.13 LREM：从列表中移除指定元素

## 示例：待办事项列表

## 4.14 BLPOP：阻塞式左端弹出操作

## 4.15 BRPOP：阻塞式右端弹出操作

## 4.16 BRPOPLPUSH：阻塞式弹出并推入操作

## 示例：带有阻塞功能的消息队列

## 4.17 重点回顾

## 第5章 集合

## 5.1 SADD：将元素添加到集合

## 5.2 SREM：从集合中移除元素

## 5.3 SMOVE：将元素从一个集合移动到另一个集合

## 5.4 SMEMBERS：获取集合包含的所有元素

## 5.5 SCARD：获取集合包含的元素数量

## 5.6 SISMEMBER：检查给定元素是否存在于集合

## 示例：唯一计数器

## 示例：打标签

## 示例：点赞

## 示例：投票

## 示例：社交关系

## 5.7 SRANDMEMBER：随机获取集合中的元素

## 5.8 SPOP：随机地从集合中移除指定数量的元素

## 示例：抽奖

## 5.9 SINTER、SINTERSTORE：对集合执行交集计算

## 5.10 SUNION、SUNIONSTORE：对集合执行并集计算

## 5.11 SDIFF、SDIFFSTORE：对集合执行差集计算

## 示例：共同关注与推荐关注

## 示例：使用反向索引构建商品筛选器

## 5.12 重点回顾

## 第6章 有序集合

## 6.1 ZADD：添加或更新成员

## 6.2 ZREM：移除指定的成员

## 6.3 ZSCORE：获取成员的分值

## 6.4 ZINCRBY：对成员的分值执行自增或自减操作

## 6.5 ZCARD：获取有序集合的大小

## 6.6 ZRANK、ZREVRANK：获取成员在有序集合中的排名

## 6.7 ZRANGE、ZREVRANGE：获取指定索引范围内的成员

## 示例：排行榜

## 6.8 ZRANGEBYSCORE、ZREVRANGEBYSCORE：获取指定分值范围内的成员

## 6.9 ZCOUNT：统计指定分值范围内的成员数量

## 示例：时间线

## 6.10 ZREMRANGEBYRANK：移除指定排名范围内的成员

## 6.11 ZREMRANGEBYSCORE：移除指定分值范围内的成员

## 6.12 ZUNIONSTORE、ZINTERSTORE：有序集合的并集运算和交集运算

## 示例：商品推荐

## 6.13 ZRANGEBYLEX、ZREVRANGEBYLEX：返回指定字典序范围内的成员

## 6.14 ZLEXCOUNT：统计位于字典序指定范围内的成员数量

## 6.15 ZREMRANGEBYLEX：移除位于字典序指定范围内的成员

## 示例：自动补全

## 6.16 ZPOPMAX、ZPOPMIN：弹出分值最高和最低的成员

## 6.17 BZPOPMAX、BZPOPMIN：阻塞式最大/最小元素弹出操作

## 6.18 重点回顾

## 第7章 HyperLogLog

## 7.1 HyperLogLog简介

## 7.2 PFADD：对集合元素进行计数

## 7.3 PFCOUNT：返回集合的近似基数

## 示例：优化唯一计数器

## 示例：检测重复信息

## 7.4 PFMERGE：计算多个HyperLogLog的并集

## 示例：实现每周/月度/年度计数器

## 7.5 重点回顾

## 第8章 位图

## 8.1 SETBIT：设置二进制位的值

## 8.2 GETBIT：获取二进制位的值

## 8.3 BITCOUNT：统计被设置的二进制位数量

## 示例：用户行为记录器

## 8.4 BITPOS：查找第一个指定的二进制位值

## 8.5 BITOP：执行二进制位运算

## 示例：0-1矩阵

## 8.6 BITFIELD：在位图中存储整数值

## 示例：紧凑计数器

## 8.7 使用字符串命令对位图进行操作

## 8.8 重点回顾

## 第9章 地理坐标

## 9.1 GEOADD：存储坐标

## 9.2 GEOPOS：获取指定位置的坐标

## 9.3 GEODIST：计算两个位置之间的直线距离

## 示例：具有基本功能的用户地理位置程序

## 9.4 GEORADIUS：查找指定坐标半径范围内的其他位置

## 9.5 GEORADIUSBYMEMBER：查找指定位置半径范围内的其他位置

## 示例：查找附近用户

## 9.6 GEOHASH：获取指定位置的Geohash值

## 9.7 使用有序集合命令操作GEO数据

## 9.8 重点回顾

## 第10章 流

## 10.1 XADD：追加新元素到流的末尾

## 10.2 XTRIM：对流进行修剪

## 10.3 XDEL：移除指定元素

## 10.4 XLEN：获取流包含的元素数量

## 10.5 XRANGE、XREVRANGE：访问流中元素

## 10.6 XREAD：以阻塞或非阻塞方式获取流元素

## 示例：消息队列

## 10.7 消费者组

## 10.8 XGROUP：管理消费者组

## 10.9 XREADGROUP：读取消费者组中的消息

## 10.10 XPENDING：显示待处理消息的相关信息

## 10.11 XACK：将消息标记为“已处理”

## 10.12 XCLAIM：转移消息的归属权

## 10.13 XINFO：查看流和消费者组的相关信息

## 示例：为消息队列提供消费者组功能

## 10.14 重点回顾

## 02第二部分 附加功能

## 11.1 SELECT：切换至指定的数据库

## 11.2 KEYS：获取所有与给定匹配符相匹配的键

## 11.3 SCAN：以渐进方式迭代数据库中的键

## 示例：构建数据库迭代器

## 11.4 RANDOMKEY：随机返回一个键

## 11.5 SORT：对键的值进行排序

## 11.6 EXISTS：检查给定键是否存在

## 11.7 DBSIZE：获取数据库包含的键值对数量

## 11.8 TYPE：查看键的类型

## 示例：数据库取样程序

## 11.9 RENAME、RENAMENX：修改键名

## 11.10 MOVE：将给定的键移动到另一个数据库

## 11.11 DEL：移除指定的键

## 11.12 UNLINK：以异步方式移除指定的键

## 11.13 FLUSHDB：清空当前数据库

## 11.14 FLUSHALL：清空所有数据库

## 11.15 SWAPDB：互换数据库

## 示例：使用SWAPDB命令实行在线替换数据库

## 11.16 重点回顾

## 第12章 自动过期

## 12.1 EXPIRE、PEXPIRE：设置生存时间

## 示例：带有自动移除特性的缓存程序

## 12.2 SET命令的EX选项和PX选项

## 示例：带有自动释放特性的锁

## 12.3 EXPIREAT、PEXPIREAT：设置过期时间

## 12.4 TTL、PTTL：获取键的剩余生存时间

## 示例：自动过期的登录会话

## 示例：自动淘汰冷门数据

## 12.5 重点回顾

## 第13章 流水线与事务

## 13.1 流水线

## 示例：使用流水线优化随机键创建程序

## 13.2 事务

## 示例：实现mlpop()函数

## 13.3 带有乐观锁的事务

## 示例：带有身份验证功能的锁

## 示例：带有身份验证功能的计数信号量

## 13.4 重点回顾

## 第14章 Lua脚本

## 14.1 EVAL：执行脚本

## 示例：使用脚本重新实现带有身份验证功能的锁

## 示例：实现LPOPRPUSH命令

## 14.2 SCRIPT LOAD和EVALSHA：缓存并执行脚本

## 14.3 脚本管理

## 14.4 内置函数库

## 14.5 脚本调试

## 14.6 重点回顾

## 第15章 持久化

## 15.1 RDB持久化

## 15.2 AOF持久化

## 15.3 RDB-AOF混合持久化

## 15.4 同时使用RDB持久化和AOF持久化

## 15.5 无持久化

## 15.6 SHUTDOWN：关闭服务器

## 15.7 重点回顾

## 第16章 发布与订阅

## 16.1 PUBLISH：向频道发送消息

## 16.2 SUBSCRIBE：订阅频道

## 16.3 UNSUBSCRIBE：退订频道

## 16.4 PSUBSCRIBE：订阅模式

## 16.5 PUNSUBSCRIBE：退订模式

## 16.6 PUBSUB：查看发布与订阅的相关信息

## 示例：广播系统

## 16.7 重点回顾

## 第17章 模块

## 17.1 模块的管理

## 17.2 ReJSON模块

## 17.3 RediSQL模块

## 17.4 RediSearch模块

## 17.5 重点回顾

## 03第三部分 多机功能


- 📌 虽然一个主服务器可以拥有多个从服务器，但一个从服务器只能拥有一个主服务器。换句话说，Redis提供的是单主复制功能，而不是多主复制功能。 
    - ⏱ 2023-09-06 09:26:12 

- 📌 在默认情况下，处于复制模式的主服务器既可以执行写操作也可以执行读操作，而从服务器则只能执行读操作， 
    - ⏱ 2023-09-06 09:26:22 

- 📌 通过同时使用Redis的复制功能和Sentinel功能，用户可以为整个Redis系统提供高可用特性。具有这一特性的Redis系统在主服务器停机时，将会自动挑选一个从服务器作为新的主服务器，以此来继续为客户提供服务，避免造成整个系统停机。 
    - ⏱ 2023-09-06 09:27:06 
## 18.1 REPLICAOF：将服务器设置为从服务器

## 18.2 ROLE：查看服务器的角色

## 18.3 数据同步


- 📌 需要注意的是，因为在线更新是异步进行的，所以在主服务器执行完写命令之后，直到从服务器也执行完相同写命令的这段时间里，主从服务器的数据库将出现短暂的不一致，因此要求强一致性的程序可能需要直接读取主服务器而不是读取从服务器。 
    - ⏱ 2023-09-06 09:29:53 

- 📌 在Redis 2.8版本以前，重同步操作是通过直接进行完整同步来实现的，但是这种重同步方法在从服务器只是短暂下线的情况下是非常浪费资源的：主从服务器的数据库在连接断开之前一直都是相同的，造成数据不一致的原因可能仅仅是主服务器比从服务器多执行了几个写命令，而为了补上这部分写命令所产生的数据，却要大费周章地重新进行一次完整同步，这毫无疑问是非常低效的。 
    - ⏱ 2023-09-06 09:30:23 

- 📌 2.8版本开始使用新的重同步功能去代替原来的重同步功能：●当一个Redis服务器成为另一个服务器的主服务器时，它会把每个被执行的写命令都记录到一个特定长度的先进先出队列中。●当断线的从服务器尝试重新连接主服务器的时候，主服务器将检查从服务器断线期间，被执行的那些写命令是否仍然保存在队列里面。如果是，那么主服务器就会直接把从服务器缺失的那些写命令发送给从服务器执行，从服务器通过执行这些写命令就可以重新与主服务器保持一致，这样就避免了重新进行完整同步的麻烦。●如果从服务器缺失的那些写命令已经不存在于队列当中，那么主从服务器将进行一次完整同步。因为新的重同步功能需要使用先进先出队列来记录主服务器执行过的写命令，所以这个队列的体积越大，它能够记录的写命令就越多，从服务器断线之后能够快速地重新回到一致状态的机会也就越大。Redis为这个队列设置的默认大小为1MB，用户也可以根据自己的需要，通过配置选项repl-backlog-size来修改这个队列的大小。 
    - ⏱ 2023-09-06 09:31:16 
## 18.4 无须硬盘的复制


- 📌 Redis从2.8.18版本开始引入无须硬盘的复制特性（diskless replication）：启用了这个特性的主服务器在接收到REPLICAOF命令时将不会再在本地创建RDB文件，而是会派生出一个子进程，然后由子进程通过套接字直接将RDB文件写入从服务器。这样主服务器就可以在不创建RDB文件的情况下，完成与从服务器的数据同步。要使用无须硬盘的复制特性，我们只需要将repl-diskless-sync配置选项的值设置为yes即可： 
    - ⏱ 2023-09-06 09:32:02 

- 📌 最后要注意的是，无须硬盘的复制特性只是避免了在主服务器上创建RDB文件，但仍然需要在从服务器上创建RDB文件 
    - ⏱ 2023-09-06 09:33:08 
## 18.5 降低数据不一致情况出现的概率


- 📌 为了尽可能地降低数据不一致的出现概率，Redis从2.8版本开始引入了两个以min-replicas开头的配置选项：​​​​​​​​​ min-replicas-max-lag <seconds>￼ ￼ ​​​​​​​min-replicas-to-write <numbers>​​用户设置了这两个配置选项之后，主服务器只会在从服务器的数量大于等于min-replicas-to-write选项的值，并且这些从服务器与主服务器最后一次成功通信的间隔不超过min-replicas-max-lag选项的值时才会执行写命令。 
    - ⏱ 2023-09-06 09:36:07 
## 18.6 可写的从服务器


- 📌 使用可写从服务器的注意事项在使用可写的从服务器时，用户需要注意以下几个方面：●在主从服务器都可写的情况下，程序必须将写命令发送到正确的服务器上，不能把需要在主服务器执行的写命令发送给从服务器执行，也不能把需要在从服务器执行的写命令发送给主服务器执行，否则就会出现数据错误。●从服务器执行写命令得到的数据，可能会被主服务器发送的写命令覆盖。比如，如果从服务器在执行了客户端发送的SET msg "hello from client"命令之后，又接收到了主服务器发送的SET msg "hello from master"命令，那么客户端写入的msg键将被主服务器写入的msg键覆盖。基于这个原因，客户端在从服务器上面执行写命令时，应该尽量避免与主服务器发生键冲突，换句话说，用户应该让客户端和主服务器分别对从服务器数据库中不同的键进行写入，而不要让客户端和主服务器都去写相同的键。●当从服务器与主服务器进行完整同步时，从服务器数据库包含的所有数据都将被清空，其中包括客户端写入的数据。●为了减少内存占用，降低键冲突发生的可能性，并确保主从服务器的数据同步操作可以顺利进行，客户端写入从服务器的数据应该在使用完毕之后尽快删除。一个比较简单的方法是在客户端向从服务器写入数据的同时，为数据设置一个比较短的过期时间，使得这些数据可以在使用完毕之后自动被删除。 
    - ⏱ 2023-09-06 22:28:46 
## 示例：使用从服务器处理复杂计算操作

## 18.7 脚本复制

## 18.8 重点回顾

## 第19章 Sentinel

## 19.1 启动Sentinel

## 19.2 Sentinel网络

## 19.3 Sentinel管理命令

## 19.4 在线配置Sentinel

## 示例：使用redis-py管理Sentinel

## 19.5 重点回顾

## 第20章 集群

## 20.1 基本特性


- 📌 在Redis集群中，各个Redis服务器被称为节点（node），其中主节点（master node）负责处理客户端发送的读写命令请求，而从节点（replica/slave node）则负责对主节点进行复制。除了复制功能之外，Redis集群还提供了类似于单机版Redis Sentinel的功能，以此来为集群提供高可用特性。简单来说，集群中的各个节点将互相监视各自的运行状况，并在某个主节点下线时，通过提升该节点的从节点为新主节点来继续提供服务。 
    - ⏱ 2023-09-06 23:05:06 

- 📌 与单机版Redis将整个数据库放在同一台服务器上的做法不同，Redis集群通过将数据库分散存储到多个节点上来平衡各个节点的负载压力。 
    - ⏱ 2023-09-06 23:05:36 

- 📌 除了节点之间互通信息带来的性能损耗之外，单个Redis集群节点处理命令请求的性能与单个Redis服务器处理命令请求的性能几乎别无二致。从理论上来讲，集群每增加一倍数量的主节点，集群对于命令请求的处理性能就会提高一倍。 
    - ⏱ 2023-09-06 23:06:36 
## 20.2 搭建集群


- 📌 在成功构建起集群之后，我们就可以使用客户端来连接并使用集群了，要做到这一点，最简单的就是使用Redis附带的redis-cli客户端。在连接集群节点而不是单机Redis服务器时，我们需要向redis-cli提供c（cluster，集群）参数以指示客户端进入集群模式，并通过h（host，主机地址）参数或p（port，端口号）参数指定集群中的某个节点作为入口： 
    - ⏱ 2023-09-06 23:08:53 

- 📌 如果接收到命令请求的节点并非负责处理命令所指键的节点，那么客户端将根据节点提示的转向信息再次向正确的节点发送命令请求，Redis集群把这个动作称为“转向”（redirect） 
    - ⏱ 2023-09-06 23:09:25 
## 示例：使用客户端连接集群


- 📌 为了连接集群，我们需要向客户端提供集群的节点地址。因为节点与节点之间一般都可以自动发现，所以我们通常只需要给定一个节点作为入口即可： 
    - ⏱ 2023-09-06 23:11:14 
## 20.3 散列标签

## 20.4 打开/关闭从节点的读命令执行权限

## 20.5 集群管理工具redis-cli

## 20.6 集群管理命令

## 20.7 槽管理命令

## 20.8 重点回顾

## 附录A Redis安装方法

## A1．免安装试运行

## A2．在macOS上安装

## A3．在Linux上安装

## A4．在Windows上安装

## 附录B redis-py安装方法

## 附录C Redis命令索引表


# 读书笔记

## 18.3 数据同步

### 划线评论
- 📌 当一个Redis服务器成为另一个服务器的主服务器时，它会把每个被执行的写命令都记录到一个特定长度的先进先出队列中。  ^225207353-7L1bq8toO
    - 💭 一个环形队列
    - ⏱ 2023-09-06 09:31:29
   

# 本书评论
